{"version":3,"sources":["../src/protocols/aave.ts","../src/protocols/uniswap.ts","../src/protocols/lido.ts","../src/protocols/index.ts","../src/actions/lending.ts","../src/actions/stake.ts","../src/providers/wallet.ts","../src/types/index.ts"],"sourcesContent":["import { Pool, EthereumTransactionTypeExtended } from \"@aave/contract-helpers\";\nimport { BigNumber, ethers, providers } from \"ethers\";\n\nimport { parseUnits } from \"ethers/lib/utils\";\n\nimport {\n    type ILendingProtocol,\n    type SupplyParams,\n    type WithdrawParams,\n} from \"./interfaces\";\nimport type { Transaction } from \"./interfaces\";\n\nimport { AaveV3Base } from \"@bgd-labs/aave-address-book\";\n\nexport class AaveProtocol implements ILendingProtocol {\n    private async submitTransaction(\n        provider: providers.Provider,\n        wallet: ethers.Wallet,\n        tx: EthereumTransactionTypeExtended\n    ): Promise<Transaction> {\n        console.log(\"Preparing to send transaction...\");\n        const extendedTxData = await tx.tx();\n        console.log(\"Got extended transaction data\");\n        const { from, ...txData } = extendedTxData;\n        console.log(`Transaction from address: ${from}`);\n\n        console.log(\"Sending transaction...\");\n        const txResponse = await wallet.sendTransaction(txData);\n        console.log(`Transaction sent with hash: ${txResponse.hash}`);\n\n        return {\n            hash: txResponse.hash as `0x${string}`,\n            from: from as `0x${string}`,\n            to: txData.to as `0x${string}`,\n            value: BigInt(txData.value || 0),\n        };\n    }\n\n    async supply(params: SupplyParams): Promise<Transaction> {\n        const { chain, amount, asset, data, walletProvider } = params;\n        console.log(\n            `Calling the inner AAVE logic to supply ${amount} ${asset}`\n        );\n\n        try {\n            walletProvider.switchChain(chain);\n            console.log(`Switched to chain: ${chain}`);\n\n            const walletClient = walletProvider.getWalletClient(chain);\n            console.log(`Got wallet client for chain: ${chain}`);\n\n            // Log the RPC URL from the transport\n            console.log(`Transport RPC URL: ${walletClient.transport.url}`);\n            const provider = new providers.JsonRpcProvider(walletClient.transport.url);\n            console.log(`Created ethers provider`);\n\n            const ethers_wallet = new ethers.Wallet(\n                process.env.EVM_PRIVATE_KEY,\n                provider\n            );\n            ethers_wallet.connect(provider);\n            console.log(`Created ethers wallet`);\n\n            const pool = new Pool(ethers_wallet.provider, {\n                POOL: AaveV3Base.POOL,\n                WETH_GATEWAY: AaveV3Base.WETH_GATEWAY,\n            });\n            // todo extend to more chains\n            console.log(\n                `Initialized Aave Pool with contract: ${AaveV3Base.POOL}`\n            );\n\n            // Get the reserve address for the input asset\n            const assetKey = Object.keys(AaveV3Base.ASSETS).find(\n                (key) => key.toLowerCase() === asset.toLowerCase()\n            );\n            const reserve = assetKey\n                ? AaveV3Base.ASSETS[assetKey].UNDERLYING\n                : undefined;\n\n            if (!reserve) {\n                throw new Error(`Unsupported asset: ${asset}`);\n            }\n            const decimals = AaveV3Base.ASSETS[assetKey].decimals;\n            // Convert amount to proper decimals\n            const amountInWei = parseUnits(amount, decimals);\n            console.log(\n                `Converted amount ${amount} to wei: ${amountInWei.toString()}`\n            );\n\n            console.log(`Reserve: ${reserve}`);\n            // Prepare supply parameters\n            const supplyParams = {\n                user: walletClient.account?.address as string,\n                reserve: reserve, // The address of the reserve\n                amount: amount,\n            };\n\n            console.log(`Prepared supply params:`, supplyParams);\n\n            // Get supply transaction\n            const txs = await pool.supply(supplyParams);\n\n            console.log(`Generated ${txs.length} supply transaction(s)`);\n\n            // Send some example read transaction to assert the provider and the connection\n            const balance = await provider.getBalance(\n                walletClient.account.address\n            );\n            console.log(`Balance: ${balance}`);\n\n            // Submit the transactions\n            if (txs && txs.length > 0) {\n                console.log(`Submitting supply transactions`);\n                const results = [];\n                for (const tx of txs) {\n                    const result = await this.submitTransaction(\n                        ethers_wallet.provider,\n                        ethers_wallet,\n                        tx\n                    );\n                    results.push(result);\n                }\n                // Return the last transaction\n                return results[results.length - 1];\n            }\n\n            throw new Error(\"No transaction generated from Aave Pool\");\n        } catch (error) {\n            console.error(\"Aave supply error:\", error);\n            throw new Error(`Aave supply failed: ${error.message}`);\n        }\n    }\n\n    async withdraw(params: WithdrawParams): Promise<Transaction> {\n        const { amount, asset } = params;\n        console.log(\n            `Calling the inner AAVE logic to withdraw ${amount} ${asset}`\n        );\n        try {\n            throw new Error(\"Not implemented\");\n        } catch (error) {\n            console.error(\"Aave withdraw error:\", error);\n            throw new Error(`Aave withdraw failed: ${error.message}`);\n        }\n    }\n}\n","import { parseEther, type Hex } from \"viem\";\nimport { IDEXProtocol, SwapParams, LiquidityParams } from \"./interfaces\";\nimport type { Transaction } from \"./interfaces\";\n\nexport class UniswapProtocol implements IDEXProtocol {\n    async swap(params: SwapParams): Promise<Transaction> {\n        const {\n            walletProvider,\n            chain,\n            contract,\n            tokenIn,\n            tokenOut,\n            amount,\n            slippage,\n        } = params;\n\n        await walletProvider.switchChain(chain);\n        const walletClient = walletProvider.getWalletClient(chain);\n\n        // Implement Uniswap-specific swap logic here\n        // Example mock implementation\n        return {\n            hash: \"0x123\",\n            from: walletClient.account?.address || \"0x456\",\n            to: \"0x789\",\n            value: parseEther(amount),\n        };\n    }\n\n    async addLiquidity(params: LiquidityParams): Promise<Transaction> {\n        const {\n            walletProvider,\n            chain,\n            contract,\n            tokenA,\n            tokenB,\n            amount,\n            amountB,\n        } = params;\n\n        await walletProvider.switchChain(chain);\n        const walletClient = walletProvider.getWalletClient(chain);\n\n        // Implement Uniswap-specific liquidity addition logic\n        return {\n            hash: \"0x123\",\n            from: walletClient.account?.address || \"0x456\",\n            to: \"0x789\",\n            value: parseEther(\"0\"),\n        };\n    }\n\n    async getQuote(params: SwapParams): Promise<string> {\n        // Implement quote logic\n        return \"0\";\n    }\n}\n","import { parseEther, type Hex } from \"viem\";\nimport { IStakingProtocol, StakingParams } from \"./interfaces\";\nimport type { Transaction } from \"./interfaces\";\n\nexport class LidoProtocol implements IStakingProtocol {\n    async stake(params: StakingParams): Promise<Transaction> {\n        const { walletProvider, chain, contract, amount } = params;\n\n        await walletProvider.switchChain(chain);\n        const walletClient = walletProvider.getWalletClient(chain);\n\n        // Implement Lido-specific staking logic\n        return {\n            hash: \"0x123\",\n            from: walletClient.account?.address || \"0x456\",\n            to: \"0x789\",\n            value: parseEther(amount),\n        };\n    }\n\n    async unstake(params: StakingParams): Promise<Transaction> {\n        const { walletProvider, chain, contract, amount } = params;\n\n        await walletProvider.switchChain(chain);\n        const walletClient = walletProvider.getWalletClient(chain);\n\n        // Implement Lido-specific unstaking logic\n        return {\n            hash: \"0x123\",\n            from: walletClient.account?.address || \"0x456\",\n            to: \"0x789\",\n            value: parseEther(\"0\"),\n        };\n    }\n\n    async claimRewards(params: StakingParams): Promise<Transaction> {\n        const { walletProvider, chain, contract } = params;\n\n        await walletProvider.switchChain(chain);\n        const walletClient = walletProvider.getWalletClient(chain);\n\n        // Implement rewards claiming logic\n        return {\n            hash: \"0x123\",\n            from: walletClient.account?.address || \"0x456\",\n            to: \"0x789\",\n            value: parseEther(\"0\"),\n        };\n    }\n}\n","import { ILendingProtocol, IStakingProtocol, IDEXProtocol } from \"./interfaces\";\nimport { AaveProtocol } from \"./aave\";\nimport { UniswapProtocol } from \"./uniswap\";\nimport { LidoProtocol } from \"./lido\";\n\nconst protocols: Record<\n    string,\n    ILendingProtocol | IStakingProtocol | IDEXProtocol\n> = {\n    // Lending\n    aave: new AaveProtocol(),\n    // DEX\n    uniswap: new UniswapProtocol(),\n    // Staking\n    lido: new LidoProtocol(),\n};\n\nexport function getProtocol(\n    name: string\n): ILendingProtocol | IStakingProtocol | IDEXProtocol | undefined {\n    return protocols[name.toLowerCase()];\n}\n\n// Type-safe getters for specific protocol types\nexport function getLendingProtocol(name: string): ILendingProtocol | undefined {\n    const protocol = protocols[name.toLowerCase()];\n    return \"supply\" in protocol ? (protocol as ILendingProtocol) : undefined;\n}\n\nexport function getStakingProtocol(name: string): IStakingProtocol | undefined {\n    const protocol = protocols[name.toLowerCase()];\n    return \"stake\" in protocol ? (protocol as IStakingProtocol) : undefined;\n}\n\nexport function getDEXProtocol(name: string): IDEXProtocol | undefined {\n    const protocol = protocols[name.toLowerCase()];\n    return \"swap\" in protocol ? (protocol as IDEXProtocol) : undefined;\n}\n","import { EdwinWallet } from \"../providers/wallet\";\nimport type { Transaction } from \"../types\";\nimport { SupplyParams } from \"../protocols/interfaces/lending\";\nimport { getLendingProtocol } from \"../protocols\";\n\nexport class SupplyAction {\n    constructor(private walletProvider: EdwinWallet) {}\n\n    async supply(params: SupplyParams): Promise<Transaction> {\n        console.log(\n            `Supplying: ${params.amount} ${params.asset} to ${params.protocol} on ${params.chain})`\n        );\n\n        try {\n            // Get the appropriate protocol service based on the protocol name\n            const lendingProtocol = getLendingProtocol(params.protocol);\n            if (!lendingProtocol) {\n                throw new Error(`Unsupported protocol: ${params.protocol}`);\n            }\n\n            // Use the protocol-specific supply implementation\n            return await lendingProtocol.supply({\n                ...params,\n                walletProvider: this.walletProvider,\n            });\n        } catch (error: any) {\n            // If error has a message, use it\n            if (error.message) {\n                throw new Error(`Supply failed: ${error.message}`);\n            }\n            // Otherwise, use the error itself\n            throw new Error(`Supply failed: ${error}`);\n        }\n    }\n}","import { EdwinWallet } from \"../providers/wallet\";\nimport type { Transaction } from \"../types\";\nimport { StakingParams } from \"../protocols/interfaces/staking\";\n\n// Exported for tests\nexport class StakeAction {\n    constructor(private walletProvider: EdwinWallet) {}\n\n    async stake(params: StakingParams): Promise<Transaction> {\n        console.log(`Staking: ${params} tokens t)`);\n\n        if (!params.data) {\n            params.data = \"0x\";\n        }\n\n        // this.walletProvider.switchChain(params.chain);\n\n        const walletClient = this.walletProvider.getWalletClient(params.chain);\n\n        try {\n            return {\n                hash: \"0x123\",\n                from: \"0x456\",\n                to: \"0x789\",\n                value: 0n,\n            };\n        } catch (error: any) {\n            // If error has a message, use it\n            if (error.message) {\n                throw new Error(`Staking failed: ${error.message}`);\n            }\n            // Otherwise, use the error itself\n            throw new Error(`Staking failed: ${error}`);\n        }\n    }\n}","import {\n    createPublicClient,\n    createWalletClient,\n    formatUnits,\n    http,\n} from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport type {\n    Address,\n    WalletClient,\n    PublicClient,\n    Chain,\n    HttpTransport,\n    Account,\n    PrivateKeyAccount,\n} from \"viem\";\nimport * as viemChains from \"viem/chains\";\nimport NodeCache from \"node-cache\";\nimport * as path from \"path\";\n\nimport type { SupportedChain } from \"../types\";\n\nexport class EdwinWallet {\n    private cache: NodeCache;\n    private cacheKey: string = \"evm/wallet\";\n    private currentChain: SupportedChain = \"mainnet\";\n    private CACHE_EXPIRY_SEC = 5;\n    chains: Record<string, Chain> = { ...viemChains };\n    account: PrivateKeyAccount | undefined;\n\n    constructor(\n        accountOrPrivateKey: PrivateKeyAccount | `0x${string}`,\n        chains?: Record<string, Chain>\n    ) {\n        this.setAccount(accountOrPrivateKey);\n        this.setChains(chains);\n\n        if (chains && Object.keys(chains).length > 0) {\n            this.setCurrentChain(Object.keys(chains)[0] as SupportedChain);\n        }\n\n        this.cache = new NodeCache({ stdTTL: this.CACHE_EXPIRY_SEC });\n    }\n\n    getAddress(): Address | undefined {\n        return this.account?.address;\n    }\n\n    getCurrentChain(): Chain {\n        return this.chains[this.currentChain];\n    }\n\n    getPublicClient(\n        chainName: SupportedChain\n    ): PublicClient<HttpTransport, Chain, Account | undefined> {\n        const transport = this.createHttpTransport(chainName);\n\n        const publicClient = createPublicClient({\n            chain: this.chains[chainName],\n            transport,\n        });\n        return publicClient;\n    }\n\n    getWalletClient(chainName: SupportedChain): WalletClient {\n        const transport = this.createHttpTransport(chainName);\n\n        const walletClient = createWalletClient({\n            chain: this.chains[chainName],\n            transport,\n            account: this.account,\n        });\n\n        return walletClient;\n    }\n\n    getChainConfigs(chainName: SupportedChain): Chain {\n        const chain = viemChains[chainName];\n\n        if (!chain?.id) {\n            throw new Error(\"Invalid chain name\");\n        }\n\n        return chain;\n    }\n\n    async getWalletBalance(): Promise<string | null> {\n        try {\n            const client = this.getPublicClient(this.currentChain);\n            if (!this.account?.address) {\n                throw new Error(\"Account not set\");\n            }\n            const balance = await client.getBalance({\n                address: this.account.address,\n            });\n            const balanceFormatted = formatUnits(balance, 18);\n            console.log(\n                \"Wallet balance cached for chain: \",\n                this.currentChain\n            );\n            return balanceFormatted;\n        } catch (error) {\n            console.error(\"Error getting wallet balance:\", error);\n            return null;\n        }\n    }\n\n    async getWalletBalanceForChain(\n        chainName: SupportedChain\n    ): Promise<string | null> {\n        try {\n            const client = this.getPublicClient(chainName);\n            if (!this.account?.address) {\n                throw new Error(\"Account not set\");\n            }\n            const balance = await client.getBalance({\n                address: this.account.address,\n            });\n            return formatUnits(balance, 18);\n        } catch (error) {\n            console.error(\"Error getting wallet balance:\", error);\n            return null;\n        }\n    }\n\n    addChain(chain: Record<string, Chain>) {\n        this.setChains(chain);\n    }\n\n    switchChain(chainName: SupportedChain, customRpcUrl?: string) {\n        if (!this.chains[chainName]) {\n            const chain = EdwinWallet.genChainFromName(\n                chainName,\n                customRpcUrl\n            );\n            this.addChain({ [chainName]: chain });\n        }\n        this.setCurrentChain(chainName);\n    }\n\n    private setAccount = (\n        accountOrPrivateKey: PrivateKeyAccount | `0x${string}`\n    ) => {\n        if (typeof accountOrPrivateKey === \"string\") {\n            this.account = privateKeyToAccount(accountOrPrivateKey);\n        } else {\n            this.account = accountOrPrivateKey;\n        }\n    };\n\n    private setChains = (chains?: Record<string, Chain>) => {\n        if (!chains) {\n            return;\n        }\n        Object.keys(chains).forEach((chain: string) => {\n            this.chains[chain] = chains[chain];\n        });\n    };\n\n    private setCurrentChain = (chain: SupportedChain) => {\n        this.currentChain = chain;\n    };\n\n    private createHttpTransport = (chainName: SupportedChain) => {\n        const chain = this.chains[chainName];\n\n        if (chain.rpcUrls.custom) {\n            return http(chain.rpcUrls.custom.http[0]);\n        }\n        return http(chain.rpcUrls.default.http[0]);\n    };\n\n    static genChainFromName(\n        chainName: string,\n        customRpcUrl?: string | null\n    ): Chain {\n        const baseChain = viemChains[chainName as keyof typeof viemChains];\n\n        if (!baseChain?.id) {\n            throw new Error(\"Invalid chain name\");\n        }\n\n        const viemChain: Chain = customRpcUrl\n            ? {\n                  ...baseChain,\n                  rpcUrls: {\n                      ...baseChain.rpcUrls,\n                      custom: {\n                          http: [customRpcUrl],\n                      },\n                  },\n              }\n            : baseChain;\n\n        return viemChain;\n    }\n}\n","import type { Token } from \"@lifi/types\";\nimport type {\n    Account,\n    Address,\n    Chain,\n    Hash,\n    HttpTransport,\n    PublicClient,\n    WalletClient,\n} from \"viem\";\nimport * as viemChains from \"viem/chains\";\n\nconst _SupportedChainList = Object.keys(viemChains) as Array<\n    keyof typeof viemChains\n>;\nexport type SupportedChain = (typeof _SupportedChainList)[number];\n\n// Transaction types\nexport interface Transaction {\n    hash: Hash;\n    from: Address;\n    to: Address;\n    value: bigint;\n    data?: `0x${string}`;\n    chainId?: number;\n}\n\n// Token types\nexport interface TokenWithBalance {\n    token: Token;\n    balance: bigint;\n    formattedBalance: string;\n    priceUSD: string;\n    valueUSD: string;\n}\n\nexport interface WalletBalance {\n    chain: SupportedChain;\n    address: Address;\n    totalValueUSD: string;\n    tokens: TokenWithBalance[];\n}\n\n// Chain configuration\nexport interface ChainMetadata {\n    chainId: number;\n    name: string;\n    chain: Chain;\n    rpcUrl: string;\n    nativeCurrency: {\n        name: string;\n        symbol: string;\n        decimals: number;\n    };\n    blockExplorerUrl: string;\n}\n"],"mappings":"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","names":["parseEther","viemChains"]}